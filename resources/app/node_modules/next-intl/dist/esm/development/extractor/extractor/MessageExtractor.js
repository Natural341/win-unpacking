import path from 'path';
import { parse, print } from '@swc/core';
import { warn } from '../../plugin/utils.js';
import ASTScope from './ASTScope.js';
import KeyGenerator from './KeyGenerator.js';
import LRUCache from './LRUCache.js';

class MessageExtractor {
  static NAMESPACE_SEPARATOR = '.';
  compileCache = (() => new LRUCache(750))();
  constructor(opts) {
    this.isDevelopment = opts.isDevelopment;
    this.projectRoot = opts.projectRoot;
  }
  async processFileContent(absoluteFilePath, source) {
    const cacheKey = source;
    const cached = this.compileCache.get(cacheKey);
    if (cached) return cached;

    // Shortcut parsing if hook is not used. The Turbopack integration already
    // pre-filters this, but for webpack this feature doesn't exist, so we need
    // to do it here.
    if (!source.includes('useExtracted') && !source.includes('getExtracted')) {
      return {
        messages: [],
        source
      };
    }
    const ast = await parse(source, {
      syntax: 'typescript',
      tsx: true,
      target: 'es2022',
      decorators: true
    });
    const relativeFilePath = path.relative(this.projectRoot, absoluteFilePath);
    const processResult = await this.processAST(ast, relativeFilePath);
    const finalResult = processResult.source ? processResult : {
      ...processResult,
      source
    };
    this.compileCache.set(cacheKey, finalResult);
    return finalResult;
  }
  async processAST(ast, filePath) {
    const results = [];
    let hookLocalName = null;
    let hookType = null;
    const isDevelopment = this.isDevelopment;
    const scopeStack = [new ASTScope()];
    function currentScope() {
      return scopeStack[scopeStack.length - 1];
    }
    function createUndefinedArgument() {
      return {
        expression: {
          type: 'Identifier',
          value: 'undefined',
          optional: false,
          ctxt: 1,
          span: {
            start: 0,
            end: 0,
            ctxt: 0
          }
        }
      };
    }
    function extractStaticString(value) {
      if (value.type === 'StringLiteral') {
        return value.value;
      } else if (value.type === 'TemplateLiteral') {
        const templateLiteral = value;
        // Only handle simple template literals without expressions
        if (templateLiteral.expressions.length === 0 && templateLiteral.quasis.length === 1) {
          return templateLiteral.quasis[0].cooked || templateLiteral.quasis[0].raw;
        }
      }
      return null;
    }
    function visit(node) {
      if (typeof node !== 'object') return;
      switch (node.type) {
        case 'ImportDeclaration':
          {
            const decl = node;
            if (decl.source.value === 'next-intl') {
              for (const spec of decl.specifiers) {
                if (spec.type === 'ImportSpecifier') {
                  const importedName = spec.imported?.value;
                  const localName = spec.local.value;
                  if (importedName === 'useExtracted' || localName === 'useExtracted') {
                    hookLocalName = localName;
                    hookType = 'useTranslations';

                    // Transform import to useTranslations
                    spec.imported = undefined;
                    spec.local.value = 'useTranslations';
                  }
                }
              }
            } else if (decl.source.value === 'next-intl/server') {
              for (const spec of decl.specifiers) {
                if (spec.type === 'ImportSpecifier') {
                  const importedName = spec.imported?.value;
                  const localName = spec.local.value;
                  if (importedName === 'getExtracted' || localName === 'getExtracted') {
                    hookLocalName = localName;
                    hookType = 'getTranslations';

                    // Transform import to getTranslations
                    spec.imported = undefined;
                    spec.local.value = 'getTranslations';
                  }
                }
              }
            }
            break;
          }
        case 'VariableDeclarator':
          {
            const decl = node;
            let callExpr = null;

            // Handle direct CallExpression: const t = useExtracted();
            if (decl.init?.type === 'CallExpression' && decl.init.callee.type === 'Identifier' && decl.init.callee.value === hookLocalName) {
              callExpr = decl.init;
            }
            // Handle AwaitExpression: const t = await getExtracted();
            else if (decl.init?.type === 'AwaitExpression' && decl.init.argument.type === 'CallExpression' && decl.init.argument.callee.type === 'Identifier' && decl.init.argument.callee.value === hookLocalName) {
              callExpr = decl.init.argument;
            }
            if (callExpr && decl.id.type === 'Identifier') {
              // Extract namespace from first argument if present
              let namespace;
              if (callExpr.arguments.length > 0) {
                const firstArg = callExpr.arguments[0].expression;
                if (firstArg.type === 'StringLiteral') {
                  namespace = firstArg.value;
                } else if (firstArg.type === 'ObjectExpression') {
                  const objectExpression = firstArg;
                  for (const prop of objectExpression.properties) {
                    if (prop.type === 'KeyValueProperty') {
                      const key = prop.key;
                      if (key.type === 'Identifier' && key.value === 'namespace') {
                        const staticNamespace = extractStaticString(prop.value);
                        if (staticNamespace != null) {
                          namespace = staticNamespace;
                        }
                        break;
                      }
                    }
                  }
                }
              }
              currentScope().define(decl.id.value, 'translator', namespace);

              // Transform the call based on the hook type
              if (hookType) {
                callExpr.callee.value = hookType;
              }
            }
            break;
          }
        case 'CallExpression':
          {
            const call = node;
            let isTranslatorCall = false;
            let namespace;

            // Handle Identifier case: t("message")
            if (call.callee.type === 'Identifier') {
              const name = call.callee.value;
              const resolved = currentScope().lookup(name);
              isTranslatorCall = resolved?.kind === 'translator';
              namespace = resolved?.namespace;
            }

            // Handle MemberExpression case: t.rich, t.markup, or t.has
            else if (call.callee.type === 'MemberExpression') {
              const memberExpr = call.callee;
              if (memberExpr.object.type === 'Identifier' && memberExpr.property.type === 'Identifier') {
                const objectName = memberExpr.object.value;
                const propertyName = memberExpr.property.value;
                const resolved = currentScope().lookup(objectName);
                isTranslatorCall = resolved?.kind === 'translator' && (propertyName === 'rich' || propertyName === 'markup' || propertyName === 'has');
                namespace = resolved?.namespace;
              }
            }
            if (isTranslatorCall) {
              const arg0 = call.arguments[0]?.expression;
              let messageText = null;
              let explicitId = null;
              let description = null;
              let valuesNode = null;
              let formatsNode = null;
              function warnDynamicExpression(expressionNode) {
                const hasSpan = 'span' in expressionNode && expressionNode.span && typeof expressionNode.span === 'object' && 'start' in expressionNode.span;
                const location = hasSpan ? path.basename(filePath) : undefined;
                warn((location ? `${location}: ` : '') + 'Cannot extract message from dynamic expression, messages need to be statically analyzable. If you need to provide runtime values, pass them as a separate argument.');
              }

              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
              if (arg0) {
                // Handle object syntax: t({id: 'key', message: 'text'})
                if (arg0.type === 'ObjectExpression') {
                  const objectExpression = arg0;

                  // Look for id, message, values, and formats properties
                  for (const prop of objectExpression.properties) {
                    if (prop.type === 'KeyValueProperty') {
                      const key = prop.key;
                      if (key.type === 'Identifier' && key.value === 'id') {
                        const staticId = extractStaticString(prop.value);
                        if (staticId !== null) {
                          explicitId = staticId;
                        }
                      } else if (key.type === 'Identifier' && key.value === 'message') {
                        const staticMessage = extractStaticString(prop.value);
                        if (staticMessage != null) {
                          messageText = staticMessage;
                        } else {
                          warnDynamicExpression(prop.value);
                        }
                      } else if (key.type === 'Identifier' && key.value === 'description') {
                        const staticDescription = extractStaticString(prop.value);
                        if (staticDescription != null) {
                          description = staticDescription;
                        } else {
                          warnDynamicExpression(prop.value);
                        }
                      } else if (key.type === 'Identifier' && key.value === 'values') {
                        valuesNode = prop.value;
                      } else if (key.type === 'Identifier' && key.value === 'formats') {
                        formatsNode = prop.value;
                      }
                    }
                  }
                }

                // Handle string syntax: t('text') or t(`text`)
                else {
                  const staticString = extractStaticString(arg0);
                  if (staticString != null) {
                    messageText = staticString;
                  } else {
                    // Dynamic expression (Identifier, CallExpression, BinaryExpression, etc.)
                    warnDynamicExpression(arg0);
                  }
                }
              }
              if (messageText) {
                const callKey = explicitId || KeyGenerator.generate(messageText);
                const fullKey = namespace ? [namespace, callKey].join(MessageExtractor.NAMESPACE_SEPARATOR) : callKey;
                const message = {
                  id: fullKey,
                  message: messageText,
                  references: [{
                    path: filePath
                  }]
                };
                if (description) {
                  message.description = description;
                }
                results.push(message);

                // Transform the argument based on type
                if (arg0.type === 'StringLiteral') {
                  arg0.value = callKey;
                  arg0.raw = undefined;
                } else if (arg0.type === 'TemplateLiteral') {
                  // Replace template literal with string literal
                  Object.assign(arg0, {
                    type: 'StringLiteral',
                    value: callKey,
                    raw: undefined
                  });
                } else if (arg0.type === 'ObjectExpression') {
                  // Transform object expression to individual parameters
                  // Replace the object with the key as first argument
                  Object.assign(arg0, {
                    type: 'StringLiteral',
                    value: callKey,
                    raw: undefined
                  });

                  // Add values as second argument if present
                  if (valuesNode) {
                    if (call.arguments.length < 2) {
                      call.arguments.push({
                        // @ts-expect-error -- Node type compatible with Expression
                        expression: valuesNode
                      });
                    } else {
                      // @ts-expect-error -- Node type compatible with Expression
                      call.arguments[1].expression = valuesNode;
                    }
                  }

                  // Add formats as third argument if present
                  if (formatsNode) {
                    // Ensure we have a second argument (values or undefined)
                    while (call.arguments.length < 2) {
                      call.arguments.push(createUndefinedArgument());
                    }
                    if (call.arguments.length < 3) {
                      // Append argument
                      call.arguments.push({
                        // @ts-expect-error -- Node type compatible with Expression
                        expression: formatsNode
                      });
                    } else {
                      // Replace argument
                      // @ts-expect-error -- Node type compatible with Expression
                      call.arguments[2].expression = formatsNode;
                    }
                  }
                }

                // Check if this is a t.has call (which doesn't need fallback)
                const isHasCall = call.callee.type === 'MemberExpression' && call.callee.property.type === 'Identifier' && call.callee.property.value === 'has';

                // Add fallback message as fourth parameter in development mode (except for t.has)
                if (isDevelopment && !isHasCall) {
                  // Ensure we have at least 3 arguments
                  while (call.arguments.length < 3) {
                    call.arguments.push(createUndefinedArgument());
                  }

                  // Add fallback message
                  call.arguments.push({
                    expression: {
                      type: 'StringLiteral',
                      value: messageText,
                      raw: JSON.stringify(messageText),
                      // @ts-expect-error -- Seems required
                      ctxt: 1,
                      span: {
                        start: 0,
                        end: 0,
                        ctxt: 0
                      }
                    }
                  });
                }
              }
            }
            break;
          }
        case 'FunctionDeclaration':
        case 'FunctionExpression':
        case 'ArrowFunctionExpression':
        case 'BlockStatement':
          {
            scopeStack.push(new ASTScope(currentScope()));
            for (const key of Object.keys(node)) {
              const child = node[key];
              if (Array.isArray(child)) {
                child.forEach(item => {
                  if (item && typeof item === 'object') {
                    if ('expression' in item && typeof item.expression === 'object' && 'type' in item.expression) {
                      visit(item.expression);
                    } else if ('type' in item) {
                      visit(item);
                    }
                  }
                });
              } else if (child && typeof child === 'object' && 'type' in child) {
                visit(child);
              }
            }
            scopeStack.pop();
            return;
          }
      }

      // Generic recursion
      for (const key of Object.keys(node)) {
        const child = node[key];
        if (Array.isArray(child)) {
          child.forEach(item => {
            if (item && typeof item === 'object') {
              if ('expression' in item && item.expression && typeof item.expression === 'object' && 'type' in item.expression) {
                visit(item.expression);
              } else if ('type' in item) {
                visit(item);
              }
            }
          });
        } else if (child && typeof child === 'object' && 'type' in child) {
          visit(child);
        }
      }
    }
    visit(ast);
    return {
      messages: results,
      source: (await print(ast)).code
    };
  }
}

export { MessageExtractor as default };
