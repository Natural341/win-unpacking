import e from"path";import{parse as t,print as s}from"@swc/core";import{warn as n}from"../../plugin/utils.js";import i from"./ASTScope.js";import r from"./KeyGenerator.js";import a from"./LRUCache.js";class o{static NAMESPACE_SEPARATOR=".";compileCache=(()=>new a(750))();constructor(e){this.isDevelopment=e.isDevelopment,this.projectRoot=e.projectRoot}async processFileContent(s,n){const i=n,r=this.compileCache.get(i);if(r)return r;if(!n.includes("useExtracted")&&!n.includes("getExtracted"))return{messages:[],source:n};const a=await t(n,{syntax:"typescript",tsx:!0,target:"es2022",decorators:!0}),o=e.relative(this.projectRoot,s),l=await this.processAST(a,o),p=l.source?l:{...l,source:n};return this.compileCache.set(i,p),p}async processAST(t,a){const l=[];let p=null,c=null;const u=this.isDevelopment,f=[new i];function y(){return f[f.length-1]}function m(e){if("StringLiteral"===e.type)return e.value;if("TemplateLiteral"===e.type){const t=e;if(0===t.expressions.length&&1===t.quasis.length)return t.quasis[0].cooked||t.quasis[0].raw}return null}return function t(s){if("object"==typeof s){switch(s.type){case"ImportDeclaration":{const d=s;if("next-intl"===d.source.value){for(const v of d.specifiers)if("ImportSpecifier"===v.type){const g=v.imported?.value,x=v.local.value;"useExtracted"!==g&&"useExtracted"!==x||(p=x,c="useTranslations",v.imported=void 0,v.local.value="useTranslations")}}else if("next-intl/server"===d.source.value)for(const h of d.specifiers)if("ImportSpecifier"===h.type){const b=h.imported?.value,j=h.local.value;"getExtracted"!==b&&"getExtracted"!==j||(p=j,c="getTranslations",h.imported=void 0,h.local.value="getTranslations")}break}case"VariableDeclarator":{const E=s;let I=null;if("CallExpression"===E.init?.type&&"Identifier"===E.init.callee.type&&E.init.callee.value===p?I=E.init:"AwaitExpression"===E.init?.type&&"CallExpression"===E.init.argument.type&&"Identifier"===E.init.argument.callee.type&&E.init.argument.callee.value===p&&(I=E.init.argument),I&&"Identifier"===E.id.type){let S;if(I.arguments.length>0){const A=I.arguments[0].expression;if("StringLiteral"===A.type)S=A.value;else if("ObjectExpression"===A.type){const k=A;for(const w of k.properties)if("KeyValueProperty"===w.type){const C=w.key;if("Identifier"===C.type&&"namespace"===C.value){const T=m(w.value);null!=T&&(S=T);break}}}}y().define(E.id.value,"translator",S),c&&(I.callee.value=c)}break}case"CallExpression":{const O=s;let L,R=!1;if("Identifier"===O.callee.type){const D=O.callee.value,P=y().lookup(D);R="translator"===P?.kind,L=P?.namespace}else if("MemberExpression"===O.callee.type){const F=O.callee;if("Identifier"===F.object.type&&"Identifier"===F.property.type){const M=F.object.value,q=F.property.value,K=y().lookup(M);R="translator"===K?.kind&&("rich"===q||"markup"===q||"has"===q),L=K?.namespace}}if(R){const N=O.arguments[0]?.expression;let V=null,_=null,z=null,B=null,G=null;function J(t){const s="span"in t&&t.span&&"object"==typeof t.span&&"start"in t.span?e.basename(a):void 0;n((s?`${s}: `:"")+"Cannot extract message from dynamic expression, messages need to be statically analyzable. If you need to provide runtime values, pass them as a separate argument.")}if(N)if("ObjectExpression"===N.type){const U=N;for(const $ of U.properties)if("KeyValueProperty"===$.type){const H=$.key;if("Identifier"===H.type&&"id"===H.value){const Q=m($.value);null!==Q&&(_=Q)}else if("Identifier"===H.type&&"message"===H.value){const W=m($.value);null!=W?V=W:J($.value)}else if("Identifier"===H.type&&"description"===H.value){const X=m($.value);null!=X?z=X:J($.value)}else"Identifier"===H.type&&"values"===H.value?B=$.value:"Identifier"===H.type&&"formats"===H.value&&(G=$.value)}}else{const Y=m(N);null!=Y?V=Y:J(N)}if(V){const Z=_||r.generate(V),ee={id:L?[L,Z].join(o.NAMESPACE_SEPARATOR):Z,message:V,references:[{path:a}]};if(z&&(ee.description=z),l.push(ee),"StringLiteral"===N.type)N.value=Z,N.raw=void 0;else if("TemplateLiteral"===N.type)Object.assign(N,{type:"StringLiteral",value:Z,raw:void 0});else if("ObjectExpression"===N.type&&(Object.assign(N,{type:"StringLiteral",value:Z,raw:void 0}),B&&(O.arguments.length<2?O.arguments.push({expression:B}):O.arguments[1].expression=B),G)){for(;O.arguments.length<2;)O.arguments.push({expression:{type:"Identifier",value:"undefined",optional:!1,ctxt:1,span:{start:0,end:0,ctxt:0}}});O.arguments.length<3?O.arguments.push({expression:G}):O.arguments[2].expression=G}const te="MemberExpression"===O.callee.type&&"Identifier"===O.callee.property.type&&"has"===O.callee.property.value;if(u&&!te){for(;O.arguments.length<3;)O.arguments.push({expression:{type:"Identifier",value:"undefined",optional:!1,ctxt:1,span:{start:0,end:0,ctxt:0}}});O.arguments.push({expression:{type:"StringLiteral",value:V,raw:JSON.stringify(V),ctxt:1,span:{start:0,end:0,ctxt:0}}})}}}break}case"FunctionDeclaration":case"FunctionExpression":case"ArrowFunctionExpression":case"BlockStatement":f.push(new i(y()));for(const se of Object.keys(s)){const ne=s[se];Array.isArray(ne)?ne.forEach((e=>{e&&"object"==typeof e&&("expression"in e&&"object"==typeof e.expression&&"type"in e.expression?t(e.expression):"type"in e&&t(e))})):ne&&"object"==typeof ne&&"type"in ne&&t(ne)}return void f.pop()}for(const ie of Object.keys(s)){const re=s[ie];Array.isArray(re)?re.forEach((e=>{e&&"object"==typeof e&&("expression"in e&&e.expression&&"object"==typeof e.expression&&"type"in e.expression?t(e.expression):"type"in e&&t(e))})):re&&"object"==typeof re&&"type"in re&&t(re)}}}(t),{messages:l,source:(await s(t)).code}}}export{o as default};
